{"version":3,"file":"use-typed-effect.mjs","sources":["../../../../../../../packages/components/bubble/src/hooks/use-typed-effect.ts"],"sourcesContent":["import { computed, unref, watch } from 'vue'\nimport { useState } from '@element-plus/hooks'\nimport { isString } from '@element-plus/utils'\nimport type { Ref, VNode } from 'vue'\n\n/**\n * Return typed content and typing status when typing is enabled.\n * Or return content directly.\n */\nconst useTypedEffect = (\n  content: Ref<VNode | object | string>,\n  typingEnabled: Ref<boolean>,\n  typingStep: Ref<number>,\n  typingInterval: Ref<number>\n): [typedContent: Ref<VNode | string>, isTyping: Ref<boolean>] => {\n  const [prevContent, setPrevContent] = useState<VNode | object | string>('')\n  const [typingIndex, setTypingIndex] = useState<number>(1)\n\n  const mergedTypingEnabled = computed(\n    () => typingEnabled.value && isString(content.value)\n  )\n\n  // Reset typing index when content changed\n  watch(content, () => {\n    const prevContentValue = unref(prevContent)\n    setPrevContent(content.value)\n    if (!mergedTypingEnabled.value && isString(content.value)) {\n      setTypingIndex(content.value.length)\n    } else if (\n      isString(content.value) &&\n      isString(prevContentValue) &&\n      content.value.indexOf(prevContentValue) !== 0\n    ) {\n      setTypingIndex(1)\n    }\n  })\n\n  // Start typing\n  watch(\n    [typingIndex, typingEnabled, content],\n    (newValue, oldValue, onCleanup) => {\n      if (\n        mergedTypingEnabled.value &&\n        isString(content.value) &&\n        unref(typingIndex) < content.value.length\n      ) {\n        const id = setTimeout(() => {\n          setTypingIndex(unref(typingIndex) + typingStep.value)\n        }, typingInterval.value)\n\n        onCleanup(() => {\n          clearTimeout(id)\n        })\n      }\n    },\n    { immediate: true }\n  )\n\n  const mergedTypingContent = computed(() => {\n    return mergedTypingEnabled.value && isString(content.value)\n      ? content.value.slice(0, unref(typingIndex))\n      : (content.value as any)\n  })\n\n  return [\n    mergedTypingContent,\n    computed(\n      () =>\n        mergedTypingEnabled.value &&\n        isString(content.value) &&\n        unref(typingIndex) < content.value.length\n    ),\n  ]\n}\n\nexport default useTypedEffect\n"],"names":[],"mappings":";;;;AASA,MAAM,cAAiB,GAAA,CACrB,OACA,EAAA,aAAA,EACA,YACA,cACgE,KAAA;AAChE,EAAA,MAAM,CAAC,WAAA,EAAa,cAAc,CAAA,GAAI,SAAkC,EAAE,CAAA,CAAA;AAC1E,EAAA,MAAM,CAAC,WAAA,EAAa,cAAc,CAAA,GAAI,SAAiB,CAAC,CAAA,CAAA;AAExD,EAAA,MAAM,mBAAsB,GAAA,QAAA;AAAA,IAC1B,MAAM,aAAA,CAAc,KAAS,IAAA,QAAA,CAAS,QAAQ,KAAK,CAAA;AAAA,GACrD,CAAA;AAGA,EAAA,KAAA,CAAM,SAAS,MAAM;AACnB,IAAM,MAAA,gBAAA,GAAmB,MAAM,WAAW,CAAA,CAAA;AAC1C,IAAA,cAAA,CAAe,QAAQ,KAAK,CAAA,CAAA;AAC5B,IAAA,IAAI,CAAC,mBAAoB,CAAA,KAAA,IAAS,QAAS,CAAA,OAAA,CAAQ,KAAK,CAAG,EAAA;AACzD,MAAe,cAAA,CAAA,OAAA,CAAQ,MAAM,MAAM,CAAA,CAAA;AAAA,KAEnC,MAAA,IAAA,QAAA,CAAS,OAAQ,CAAA,KAAK,CACtB,IAAA,QAAA,CAAS,gBAAgB,CAAA,IACzB,OAAQ,CAAA,KAAA,CAAM,OAAQ,CAAA,gBAAgB,MAAM,CAC5C,EAAA;AACA,MAAA,cAAA,CAAe,CAAC,CAAA,CAAA;AAAA,KAClB;AAAA,GACD,CAAA,CAAA;AAGD,EAAA,KAAA;AAAA,IACE,CAAC,WAAa,EAAA,aAAA,EAAe,OAAO,CAAA;AAAA,IACpC,CAAC,QAAU,EAAA,QAAA,EAAU,SAAc,KAAA;AACjC,MACE,IAAA,mBAAA,CAAoB,KACpB,IAAA,QAAA,CAAS,OAAQ,CAAA,KAAK,CACtB,IAAA,KAAA,CAAM,WAAW,CAAA,GAAI,OAAQ,CAAA,KAAA,CAAM,MACnC,EAAA;AACA,QAAM,MAAA,EAAA,GAAK,WAAW,MAAM;AAC1B,UAAA,cAAA,CAAe,KAAM,CAAA,WAAW,CAAI,GAAA,UAAA,CAAW,KAAK,CAAA,CAAA;AAAA,SACtD,EAAG,eAAe,KAAK,CAAA,CAAA;AAEvB,QAAA,SAAA,CAAU,MAAM;AACd,UAAA,YAAA,CAAa,EAAE,CAAA,CAAA;AAAA,SAChB,CAAA,CAAA;AAAA,OACH;AAAA,KACF;AAAA,IACA,EAAE,WAAW,IAAK,EAAA;AAAA,GACpB,CAAA;AAEA,EAAM,MAAA,mBAAA,GAAsB,SAAS,MAAM;AACzC,IAAA,OAAO,mBAAoB,CAAA,KAAA,IAAS,QAAS,CAAA,OAAA,CAAQ,KAAK,CACtD,GAAA,OAAA,CAAQ,KAAM,CAAA,KAAA,CAAM,CAAG,EAAA,KAAA,CAAM,WAAW,CAAC,IACxC,OAAQ,CAAA,KAAA,CAAA;AAAA,GACd,CAAA,CAAA;AAED,EAAO,OAAA;AAAA,IACL,mBAAA;AAAA,IACA,QAAA;AAAA,MACE,MACE,mBAAoB,CAAA,KAAA,IACpB,QAAS,CAAA,OAAA,CAAQ,KAAK,CAAA,IACtB,KAAM,CAAA,WAAW,CAAI,GAAA,OAAA,CAAQ,KAAM,CAAA,MAAA;AAAA,KACvC;AAAA,GACF,CAAA;AACF;;;;"}